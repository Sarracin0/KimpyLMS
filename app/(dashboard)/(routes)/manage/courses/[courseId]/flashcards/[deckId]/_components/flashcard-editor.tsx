'use client'

import { useMemo, useState } from 'react'
import axios from 'axios'
import toast from 'react-hot-toast'
import { Badge } from '@/components/ui/badge'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Separator } from '@/components/ui/separator'
import { Loader2, ArrowUp, ArrowDown, Trash2, Sparkles } from 'lucide-react'
import { logError } from '@/lib/logger'

export type FlashcardDeckData = {
  id: string
  title: string
  description: string | null
  isPublished: boolean
  autoGenerated: boolean
  gamificationBlockId: string
  cards: { id: string; front: string; back: string; points: number; position: number }[]
}

type FlashcardEditorProps = {
  deck: FlashcardDeckData
}

export default function FlashcardEditor({ deck }: FlashcardEditorProps) {
  const [deckState, setDeckState] = useState(deck)
  const [isSavingDeck, setIsSavingDeck] = useState(false)
  const [isPublishing, setIsPublishing] = useState(false)
  const [newCard, setNewCard] = useState({ front: '', back: '', points: 0 })
  const [savingCardId, setSavingCardId] = useState<string | null>(null)
  const [deletingCardId, setDeletingCardId] = useState<string | null>(null)

  const deckEndpoint = useMemo(() => `/api/flashcards/${deckState.id}`, [deckState.id])

  const handleDeckFieldChange = (field: 'title' | 'description', value: string) => {
    setDeckState((prev) => ({ ...prev, [field]: value }))
  }

  const handlePersistDeck = async (override?: Partial<{ title: string; description: string | null; isPublished: boolean }>) => {
    try {
      setIsSavingDeck(true)
      const payload = override ?? {
        title: deckState.title,
        description: deckState.description,
      }
      const response = await axios.patch(deckEndpoint, payload)
      setDeckState((prev) => ({ ...prev, ...response.data }))
      toast.success('Deck aggiornato')
    } catch (error) {
      toast.error('Unable to save deck changes')
      logError('FLASHCARD_DECK_SAVE', error)
    } finally {
      setIsSavingDeck(false)
    }
  }

  const handleTogglePublish = async () => {
    try {
      setIsPublishing(true)
      const nextStatus = !deckState.isPublished
      const response = await axios.patch(deckEndpoint, { isPublished: nextStatus })
      setDeckState((prev) => ({ ...prev, ...response.data }))
      toast.success(nextStatus ? 'Deck pubblicato' : 'Deck in bozza')
    } catch (error) {
      toast.error('Unable to toggle publish status')
      logError('FLASHCARD_DECK_PUBLISH', error)
    } finally {
      setIsPublishing(false)
    }
  }

  const handleCreateCard = async () => {
    if (!newCard.front.trim() || !newCard.back.trim()) {
      toast.error('Add front and back text')
      return
    }

    try {
      setSavingCardId('new')
      const response = await axios.post(`/api/flashcards/${deckState.id}/cards`, {
        front: newCard.front.trim(),
        back: newCard.back.trim(),
        points: newCard.points ?? 0,
      })
      const created = response.data as FlashcardDeckData['cards'][number]
      setDeckState((prev) => ({ ...prev, cards: [...prev.cards, created] }))
      setNewCard({ front: '', back: '', points: 0 })
      toast.success('Card added')
    } catch (error) {
      toast.error('Unable to add card')
      logError('FLASHCARD_CARD_CREATE', error)
    } finally {
      setSavingCardId(null)
    }
  }

  const handleCardFieldChange = (cardId: string, field: 'front' | 'back' | 'points', value: string | number) => {
    setDeckState((prev) => ({
      ...prev,
      cards: prev.cards.map((card) =>
        card.id === cardId
          ? {
              ...card,
              [field]: field === 'points' ? Number(value) : value,
            }
          : card,
      ),
    }))
  }

  const handleSaveCard = async (cardId: string) => {
    const card = deckState.cards.find((item) => item.id === cardId)
    if (!card) return

    try {
      setSavingCardId(cardId)
      const response = await axios.patch(`/api/flashcards/${deckState.id}/cards/${cardId}`, {
        front: card.front,
        back: card.back,
        points: card.points,
        position: card.position,
      })
      const updated = response.data as FlashcardDeckData['cards'][number]
      setDeckState((prev) => ({
        ...prev,
        cards: prev.cards.map((item) => (item.id === cardId ? { ...item, ...updated } : item)),
      }))
      toast.success('Card aggiornata')
    } catch (error) {
      toast.error('Unable to save card')
      logError('FLASHCARD_CARD_SAVE', error)
    } finally {
      setSavingCardId(null)
    }
  }

  const handleDeleteCard = async (cardId: string) => {
    try {
      setDeletingCardId(cardId)
      await axios.delete(`/api/flashcards/${deckState.id}/cards/${cardId}`)
      setDeckState((prev) => ({
        ...prev,
        cards: prev.cards.filter((card) => card.id !== cardId).map((card, index) => ({ ...card, position: index })),
      }))
      toast.success('Card eliminata')
    } catch (error) {
      toast.error('Unable to delete card')
      logError('FLASHCARD_CARD_DELETE', error)
    } finally {
      setDeletingCardId(null)
    }
  }

  const handleMoveCard = async (cardId: string, direction: 'up' | 'down') => {
    const cards = deckState.cards
    const index = cards.findIndex((card) => card.id === cardId)
    if (index === -1) return
    const newIndex = direction === 'up' ? index - 1 : index + 1
    if (newIndex < 0 || newIndex >= cards.length) return

    const reordered = [...cards]
    const [removed] = reordered.splice(index, 1)
    reordered.splice(newIndex, 0, removed)
    const updatedPositions = reordered.map((card, position) => ({ ...card, position }))
    setDeckState((prev) => ({ ...prev, cards: updatedPositions }))

    try {
      setSavingCardId(cardId)
      await axios.patch(`/api/flashcards/${deckState.id}/cards/${cardId}`, {
        position: newIndex,
      })
      toast.success('Ordine aggiornato')
    } catch (error) {
      toast.error('Unable to reorder card')
      logError('FLASHCARD_CARD_REORDER', error)
    } finally {
      setSavingCardId(null)
    }
  }

  return (
    <div className="space-y-6">
      <Card>
        <CardHeader>
          <div className="flex items-center gap-3">
            <CardTitle className="text-lg">Impostazioni deck</CardTitle>
            {deckState.autoGenerated && (
              <Badge variant="secondary" className="gap-1 text-xs">
                <Sparkles className="h-3 w-3" /> AI generated
              </Badge>
            )}
            <Badge variant={deckState.isPublished ? 'default' : 'outline'} className="text-xs">
              {deckState.isPublished ? 'Published' : 'Draft'}
            </Badge>
          </div>
        </CardHeader>
        <CardContent className="space-y-4 text-sm">
          <div className="grid gap-3 md:grid-cols-2">
            <div className="space-y-1">
              <label className="text-xs uppercase text-muted-foreground">Titolo</label>
              <Input
                value={deckState.title}
                onChange={(event) => handleDeckFieldChange('title', event.target.value)}
                onBlur={() => handlePersistDeck()}
                disabled={isSavingDeck}
              />
            </div>
            <div className="space-y-1">
              <label className="text-xs uppercase text-muted-foreground">Stato pubblicazione</label>
              <Button type="button" variant="outline" size="sm" onClick={handleTogglePublish} disabled={isPublishing}>
                {isPublishing ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                {deckState.isPublished ? 'Unpublish' : 'Publish deck'}
              </Button>
            </div>
          </div>
          <div className="space-y-1">
            <label className="text-xs uppercase text-muted-foreground">Descrizione</label>
            <Textarea
              value={deckState.description ?? ''}
              onChange={(event) => handleDeckFieldChange('description', event.target.value)}
              onBlur={() => handlePersistDeck()}
              disabled={isSavingDeck}
              placeholder="Context, learning outcomes or usage notes..."
              className="min-h-[80px]"
            />
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Nuova flashcard</CardTitle>
        </CardHeader>
        <CardContent className="grid gap-3 md:grid-cols-2">
          <div className="space-y-1">
            <label className="text-xs uppercase text-muted-foreground">Front</label>
            <Textarea
              value={newCard.front}
              onChange={(event) => setNewCard((prev) => ({ ...prev, front: event.target.value }))}
              placeholder="Domanda o stimolo"
              className="min-h-[80px]"
            />
          </div>
          <div className="space-y-1">
            <label className="text-xs uppercase text-muted-foreground">Back</label>
            <Textarea
              value={newCard.back}
              onChange={(event) => setNewCard((prev) => ({ ...prev, back: event.target.value }))}
              placeholder="Risposta o spiegazione"
              className="min-h-[80px]"
            />
          </div>
          <div className="space-y-1">
            <label className="text-xs uppercase text-muted-foreground">Points</label>
            <Input
              type="number"
              min={0}
              value={newCard.points}
              onChange={(event) => setNewCard((prev) => ({ ...prev, points: Number(event.target.value) || 0 }))}
            />
          </div>
          <div className="flex items-end">
            <Button type="button" onClick={handleCreateCard} disabled={savingCardId === 'new'} className="w-full">
              {savingCardId === 'new' ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
              Add card
            </Button>
          </div>
        </CardContent>
      </Card>

      <Card>
        <CardHeader>
          <CardTitle className="text-lg">Carte ({deckState.cards.length})</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {deckState.cards.length === 0 ? (
            <p className="text-sm text-muted-foreground">Nessuna card presente. Generane una o aggiungine manualmente.</p>
          ) : (
            deckState.cards.map((card, index) => (
              <div key={card.id} className="rounded-lg border border-border/40 bg-background/70 p-4 space-y-3 text-sm">
                <div className="flex items-center justify-between">
                  <Badge variant="outline" className="text-xs">#{index + 1}</Badge>
                  <div className="flex items-center gap-2">
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8"
                      onClick={() => handleMoveCard(card.id, 'up')}
                      disabled={index === 0 || savingCardId === card.id}
                    >
                      <ArrowUp className="h-4 w-4" />
                    </Button>
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8"
                      onClick={() => handleMoveCard(card.id, 'down')}
                      disabled={index === deckState.cards.length - 1 || savingCardId === card.id}
                    >
                      <ArrowDown className="h-4 w-4" />
                    </Button>
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      className="h-8 w-8 text-destructive"
                      onClick={() => handleDeleteCard(card.id)}
                      disabled={deletingCardId === card.id}
                    >
                      {deletingCardId === card.id ? <Loader2 className="h-4 w-4 animate-spin" /> : <Trash2 className="h-4 w-4" />}
                    </Button>
                  </div>
                </div>
                <div className="grid gap-3 md:grid-cols-2">
                  <div className="space-y-1">
                    <label className="text-xs uppercase text-muted-foreground">Front</label>
                    <Textarea
                      value={card.front}
                      onChange={(event) => handleCardFieldChange(card.id, 'front', event.target.value)}
                      className="min-h-[80px]"
                    />
                  </div>
                  <div className="space-y-1">
                    <label className="text-xs uppercase text-muted-foreground">Back</label>
                    <Textarea
                      value={card.back}
                      onChange={(event) => handleCardFieldChange(card.id, 'back', event.target.value)}
                      className="min-h-[80px]"
                    />
                  </div>
                </div>
                <div className="flex items-center justify-between">
                  <div className="w-32">
                    <label className="text-xs uppercase text-muted-foreground">Points</label>
                    <Input
                      type="number"
                      min={0}
                      value={card.points}
                      onChange={(event) => handleCardFieldChange(card.id, 'points', Number(event.target.value) || 0)}
                    />
                  </div>
                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => handleSaveCard(card.id)}
                    disabled={savingCardId === card.id}
                  >
                    {savingCardId === card.id ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                    Save card
                  </Button>
                </div>
              </div>
            ))
          )}
        </CardContent>
      </Card>

      <Separator />

      <div className="flex items-center justify-between text-xs text-muted-foreground">
        <span>Deck ID: {deckState.id}</span>
        <span>{deckState.cards.length} card{deckState.cards.length === 1 ? '' : 's'}</span>
      </div>
    </div>
  )
}
